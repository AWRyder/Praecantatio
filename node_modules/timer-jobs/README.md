timer-jobs
==========

Create timers that can run often, but not block by long executions. Great for worker-roles and such that have many jobs to do periodically.


## Installation

		$ npm install timer-jobs

## Usage

``` javascript
var TimerJob = require('timer-jobs');

var someTimer = new TimerJob({interval: 5000}, function(done) {
	console.log('hey');
	done();
});
someTimer.start();
```

## TimerJob Class

### constructor (options, callback)

Options:

- `blocking`: `boolean` - This determines if the timer should allow a new callback to be started before one finishes. Defaults to `true`.
- `interval`: Interval time, in milliseconds. Attempts to start the callback at this value.
- `autoStart`: `boolean` - No need to call `timer.start()` after creating the timer. Defaults to `false`.
- `immediate`: `boolean` - If `true`, calls the callback right when the job starts, doesn't wait for `interval` milliseconds. Defaults to `false`
- `ignoreErrors`: `boolean` - Ff `true`, automatically restarts the job if an error was sent from the callback.

Callback:

The `function` to call every `interval` milliseconds. 


### timer.start()

Starts up ye olde job!

### timer.stop()

Stop the job! If a callback is in the middle of execution, it does not cancel it. Only when it calls back.

### Event: start

``` javascript
function() {}
```

Emitted when the timer has successfully started.

### Event: stop

``` javascript
function() {}
```

Emitted when the timer has successfully stopped.

### Event: jobStart

``` javascript
function() {}
```

Emitted on every interval, BEFORE the callback function is called

### Event: jobStop

``` javascript
function([err], [args]) {}
```

Emitted every time the callback calls its `done` function. If there is an error - the job HALTS until you start it back up, or if `options.ignoreErrors` is true.

- `err`: Error passed from the callback
- `args`: Any additional arguments passed from the callback