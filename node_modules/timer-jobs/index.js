var events = require('events'),
	util = require('util'),
	debug = require('debug')('timer-jobs');

/**
 * The TimerJob class - An interval with some blocking and start/stop functionality
 * @param {object} options     An object containing options - duh
 * @param {Function} theFunction The function that gets called for every iteration of the interval
 */
function TimerJob(options, theFunction) {
	events.EventEmitter.call( this );

	options = options || {};

	// Will force timers to wait until an iteration finishes
	this.blocking = options.blocking || true;

	// Interval of timer - dead giveaway
	this.interval = options.interval || 3000;

	// Whether or not to auto-start
	this.autoStart = options.autoStart || false;

	// Whether or not to call the first interval IMMEDIATELY
	this.immediate = options.immediate || false;

	// Ignore errors and continue timers?
	this.ignoreErrors = options.ignoreErrors || false;


	this.timer = null;
	this.busy = false;
	this.theFunction = theFunction;

	if (this.autoStart) {
		this.start();
	}

	debug('TimerJob created', this);

	return this;
};

util.inherits(TimerJob, events.EventEmitter);


/**
 * Starts the interval if it hasn't already
 */
TimerJob.prototype.start = function() {
	if (!this.timer) {
		var self = this;
		this.timer = setInterval(function() {self.go()}, this.interval);
		this.emit('start');
		if (this.immediate) {
			this.go();
		}

		debug('TimerJob started', this);
	}
};


/**
 * Stops the interval if it hasn't already
 */
TimerJob.prototype.stop = function() {
	if(this.timer) {
		clearInterval(this.timer);
		this.timer = null;
		debug('TimerJob stopped', this);
	}
};


/**
 * This is the wrapper around each this.theFunction call, ensures blocking and busy statuses are correct
 */
TimerJob.prototype.go = function() {
	var self = this;
	if (!self.busy || !self.blocking) {
		self.busy = true;

		self.emit('jobStart');

		self.theFunction(function(err) {
			var args = [].slice.call(arguments);
			args.unshift('jobStop');
			self.emit.apply(self, args);
			
			if (err) {
				if (!self.ignoreErrors) {
					clearInterval(self.timer);
					self.timer = null;
				}
			}

			self.busy = false;
			if (self.timer === null) {
				self.emit('stop');
			}
		});

		debug('TimerJob go', this);
	}
};


// BAM! One export
module.exports = TimerJob;